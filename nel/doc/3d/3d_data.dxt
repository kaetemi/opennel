
/**
\page 3d_data_howto How to deal with 3d data

\author Cyril Corvazier

\subsection 3d_data_overview Overall view

3d data files in NeL are managed in a specific way.

NeL doesn't import proprietary 3d file format like .3ds. NeL only deal with NeL binary files.
NeL doesn't describe the NeL binary file format, it gives interface to import and export it.

Those files are generated by serializing some classes. Building those data is easy.
With the serial's version system, data can change and stay compatible with the futur version 
of NeL.

To get some NeL binary 3d files, you can:

- Get some NeL files from your friend or from Nevrax. :)
- Export some data with a specific plugin exporting NeL files.
- Write a file converter from your format to NeL format.
- Write a plugin for your 3d editor.

\subsection mesh Build a simple mesh

Ok, First you will need to build a simple mesh. A mesh is a class that handle one 3d object. 
It contains the vertices, the primitives, and pointers on materials. The mesh class is NL3D::CMesh.

The class NL3D::CMesh::CMeshBuild is used to build this mesh. Just fill it with appropriate values:

- VertexFlags will received flags that describe vertices format like in CVertexBuffer. Following flags can be used
	IDRV_VF_XYZ (x, y, z local value, must be present), IDRV_VF_NORMAL (normal, should be present for lighted material),
	IDRV_VF_COLOR (vertex diffuse color), IDRV_VF_SPECULAR (vertex specular color), IDRV_VF_UV[IDRV_VF_MAXSTAGES] 
	(flags for each UV channel used, max IDRV_VF_MAXSTAGES UV channels), IDRV_VF_W[IDRV_VF_MAXW] (flags for each
	weighting channel used). Some exemple:
	- IDRV_VF_XYZ|IDRV_VF_NORMAL, simple lighted vertex
	- IDRV_VF_XYZ|IDRV_VF_NORMAL|IDRV_VF_UV[0]|IDRV_VF_UV[1], simple lighted vertex with two mapping channels
	- IDRV_VF_XYZ|IDRV_VF_NORMAL|IDRV_VF_W[0]|IDRV_VF_W[1]|IDRV_VF_W[2]|IDRV_VF_W[3], simple lighted vertex with 4 weights for skinning matrix.
- Materials is an array of materials. Resize it and fill it with your materials data. See material_howto for more information.
- Vertices is the vertex array. Only local x, y and z coordinates are stored here. Resize it and fill it.
- Faces is the triangle array. Each triangle is composed by 3 NL3D::CMesh::CCorner and a material Id. The corner must be fill like this:
	- Vertex must receive the vertex id used at this corner.
	- Normal must receive the local normalized normal at this corner.
	- Uvs must receive the UV values for each mapping channels defined in VertexFlags.
	- Color must receive the diffuse color if IDRV_VF_COLOR is defined in VertexFlags.
	- Specular must receive the specular color if IDRV_VF_COLOR is defined in VertexFlags.
	- Weights must receive the weight values for each weighting channels defined in VertexFlags.

\code
	// Let's assume that those namespaces are used: NL3D, NLMISC

	// My building struct
	CMesh::CMeshBuild buildStruct;

	// Filling the struct..
	...

	// Create a CMesh
	CMesh myMesh;

	// Build the mesh
	myMesh.build (buildStruct);

	// Create a mesh for export
	CShapeStream streamableMesh (&myMesh)

	// Ok, ready to export

\endcode

You have normals, colors and uvs per vertex per triangle.
Once you have filled all those values, call NL3D::CMesh::build() on the mesh. 
NL3D::CMesh::build() will optimize your corners by merging the same one.

To simplify the serialization of a shape, use the class NL3D::CShapeStream construct with your shape pointer and serialize it.
This class will serial a valid .shape file with header and polymorphic serialization of the shape, materials and textures.
Here is the code of NL3D::CShapeStream::serial():

\code
void CShapeStream::serial(NLMISC::IStream &f) throw(NLMISC::EStream)
{
	// First, serial an header or checking if it is correct
	f.serialCheck ((uint32)'PAHS');

	// Then, serial the shape
	f.serialPolyPtr (_Shape);

	// Ok, it's done
}
\endcode

Your mesh is ready to export.

\subsection zone Build a landscape zone

It's coming..

\subsection serial Serial a NeL class

Now you have build your data, you must know how to serial a NeL class. Let's assume that you want to read a landscape zone from a file:

\code
	// Let's assume that those namespaces are used: NL3D, NLMISC

	// Your object to load into
	CZone			zone;

	// Create an input file stream
	CIFile			fileIn;

	// Open your file for writing
	if (fileIn.open ("myZoneFile.zone"))
	{
		// Catch some error
		try
		{
			// Read your object
			zone.serial (fileIn);
		}
		catch (CException& except)
		{
			// Handle errors. File truncated, bad version, etc...
		}
	}
\endcode

Then how to write a shape in a file ? Easy too..

\code
	// Let's assume that those namespaces are used: NL3D, NLMISC

	// Your shape to write
	CShapeStream	shape;

	// Create an output file stream
	COFile			fileOut;

	// Open your file for writing
	if (fileOut.open ("myExportedFile.shape"))
	{
		// Catch some error
		try
		{
			// Write your object
			shape.serial (fileOut);
		}
		catch (CException& except)
		{
			// Handle error. Disk full, etc...
		}
	}
\endcode



*/
