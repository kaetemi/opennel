/**

\page general NeL Whitepaper
\author Vincent Archer <archer@nevrax.org>

The purpose of this document is to present a general overview of the whole of the
NeL infrastructure. After reading this document, you should have a good understanding
of how NeL is structured, what parts compose it, why these parts are there, and how
they are intended to be used for the building of a finished product.

This is not an interface description or a programming manual. These interface
descriptions are also generated using the Doxygen documentation tool, and separate
general interface description documents for each component are provided. There is also a
separate global programming manual, describing exactly how to code for a complete product
using NeL components.

\section build Building system

Building systems are very different, depending on whether you work on a Windows/Visual
C++ environment, or a Unix/C++ environment (the two development environments currently
supported in the official NeL system). The building system reflects this and thus
consists of two different subsystems:

\subsection unixbuild Unix build

Building the NeL system in a Unix-based environment uses the auto-configure system
that is pretty much a standard in GNU tools and other environment-portable packages. The
NeL library top level thus has a configure.in, which autoconf/autoheader turns into
the classic configure script.

That directory, and all its subdirectories, has a Makefile.am, which automake uses to
generate a set of Makefile.in. All modifications (notably adding source files) are made
into the Makefile.am files themselves, and never to Makefile.in or Makefile. The .am
template is stored in the CVS tree, but not the rest. A full regeneration of the files
must be done after a checkout.

\subsection winbuild Windows build

[to be completed]

\section components Components

\subsection component3d 3D library

The purpose of the 3D Library is to provide a graphical view of a full 3D Universe. It
is not based on a pre-existing high-level library because of specific constraints on the
final environment to render, which is consists of large landscapes with smooth natural
features and lots of objects.

To achieve this objective, the library implements several techniques:

- Geometry:
  - The ROAM algorithm, which provides an adaptative subdivision of the landscape base
  - Use of Bezier Patches to create smooth-looking landscapes
  - Multi-Resolution Meshes, to provide a smooth reduction in polygon count as objects
    retreat further in distance
  - Object Interfaces, which allows the correct assembly of multiple "parts" of objects
    into a single mesh without leaving unconnected parts or holes
- Rendering:
  - Bump Mapping of surfaces for a more natural texture
  - Environment Map
  - Support of User Colors (specific areas in textures tagged for replacement with a
    program-defined color upon rendering)
  - Hardware T&L
  - Hardware Pixel Shaders and Vertex Shaders
- Animation:
  - Skinning, using a base skeleton for animations
  - Blended Shapes, to provide lip-sync style animations
  - Inverse kinematics
  - Blend of animations to provide smooth transitions between various animations
- Low level services:
  - Object streaming, to provide a transparent load-on-demand, including the multi-
    resolution meshes
  - Object Picking in a scene

The library works best with a set of 3DSMax plug-ins to generate data for use with the
software.

The library itself is organised in three successive layers:

- Layer 1, or driver layers, which implements the effective 3D operations. This is
  highly API and platform-dependent. Right now, an OpenGL driver is provided, but a
  directX would not require much effort.
- Layer 2, or object layer, which implements the various objects (landscapes, meshes
  and so on), and rendering
- Layer 3, or high level layer, which provide the spatial manipulation and the
  necessary interfaces to create the whole scene, and modify it according to your model
  of your universe.

Modification of the layer 1 should be very rare, as it is the most stable part of the
NeL 3D library. New extensions to OpenGL or new drivers will require intervention in
that layer.

Modification of the layer 2 occurs only if you create new object types, such as special
smooth surfaces not based on Bezier Patches, different styles of animations, and so on.

Modification of the layer 3 is reserved to changes in the whole predicate on which the
NeL library is based, as it is where objects are created and removed, their properties
altered, according to the necessities of the 3D universe.

\subsection componentai Artificial Intelligence

The purpose of the AI library is to provide a pragmatic approach to creating a distributed
agents platform. Its focus is agents; individual entities that communicate regardless of
location, using an action-reaction model.

The library provide three different categories of concepts:

- Autonomous agents
  - Basic components that can be assembled to build an agent
  - Messages that can be sent between agents
  - Triggers
- A dedicated scripting language
  - Based on a virtual machine approach (similar to Java)
  - Object oriented, with a strong agent flavor
  - Declarative rather than procedural (allows to define sets of actions, then select
    among them which one to take)
- Basic AI techniques
  - Pathfinding in a 3D universe (animated objects may have different paths depending on
    their physical abilities)
  - Basic expert system framework
  - Order-1 logic
  - Fuzzy logic operations
  - Evolutive algorithms

The library offers three different layers of code:

- Layer 1, or base classes layer, which implements the basic classes, and all the basic
  AI techniques available to agents
- Layer 2, or agent layer, which provides the base agent, and the components used to
  build an agent
- Layer 3, or scripting layer, which defines the scripting language, the virtual machine,
  and allows the programmer to create, assemble and define agent behaviour. This is where
  the AI programmer acts to create specific agents.

Modification of the layer 1 should be very infrequent, and occur only if someone wants
to add new AI techniques, or alter the communication layers between agents.

Modification of the layer 2 occurs only if you want to create different agent types. In
general, this is not necessary; the set of agents implemented in the layer 2 is assumed
to be adequate to cover all bases.

Modification of the layer 3 is where one may add new functionalities to the scripting
language, such as allowing to call other scripts (in Python, Perl, or whatever langage)
or external compiled code.

\subsection componentdb Database & File

The storage library provides access to dynamic databases and relatively static files. It
provides an API for general use, and a network service (see Network below).

[to be completed]

\subsection componentnet Network

The network library serves a twofold purpose. It provides inter-process communication,
and services.

In purely network terms, the library offers 4 layers:

- An abstraction of the network API and links (IPC may be across a network, or local
  messaging)
- A buffering and structuring of messages
- Handling of asynchronous message passing, and callbacks
- An abstraction of destination (you address a service, not an IP/Port)

These network layers are reused to build distributed services. The network library
presents both a generic service skeleton, which includes the base functions of the
distributed service:

- Initialisation
- Creation and registration of callbacks for network layer 3
- Registration to the naming service

The library will also provide pre-existing services:

- Naming service (1 per logical cluster)
  - This service handles the association between a service and the process or processes
    that execute code to provide the service
  - Handles load balancing
  - Handles connection aging
- Logging service (1 per logical cluster)
- Administrator service (1 per physical computer)
- Administrator interface (1 per logical cluster)

Finally, the network library also proposes some basic function that are required to
build a service able to "run" a 3D Universe, such as:

- Fast communication across unreliable long-delay networks
- Dead reckoning

The purely network library is typically self-contained, and not much subject to
modification, unless one wants to change the entire paradigm around which the platform
runs. Addition of a specific and non-standard network or network API would be the only
reason one would change layer 1.

The structure of distributed services is the point that requires the most attention,
as these define the logical structure of a cluster.

Fine-tuning the basic network services is probably the place where most modifications can
be made.

\subsection componentpython Python scripting

Python is currently considered as the tool that will bind all the components from NeL
and the client or server together.

\subsection componentsys System

This library section deals with all the system-dependent aspects of the NeL library.
It handles interfaces with the system functions, such as starting processes, managing
system resources, and so on.

[to be completed]

\subsection componentmisc Miscellaneous

This contains all the various utility functions, classes and objects that are not
complex and large enough to warrant their own separate component.

[to be completed]

\section externals External components

The following external components are used to build the NeL system. These components
are either included directly in the NeL system and are available immediately when
extracting the NeL source tree, while others are kept separate, and require you to
obtain them separately prior to building NeL.

- Autoconfig & Automake : The GNU standard configuration tools for Open Source development.
- Clanlib : A portable system interface
- STL Ports
- CLAP

[to be completed]
 */